var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#SciMLLogging.AbstractVerbositySpecifier","page":"API Reference","title":"SciMLLogging.AbstractVerbositySpecifier","text":"AbstractVerbositySpecifier{T}\n\nAbstract base type for verbosity specifiers.\n\nThe type parameter T is a boolean:\n\nT = true: Verbosity enabled, messages will be processed\nT = false: Verbosity disabled, no runtime overhead\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLLogging.Verbosity","page":"API Reference","title":"SciMLLogging.Verbosity","text":"Verbosity\n\nA sum type representing different verbosity levels.\n\nVariants\n\nNone: No output\nInfo: Maps to Logging.Info\nWarn: Maps to Logging.Warn  \nError: Maps to Logging.Error\nLevel(Int): Custom log level\nEdge: Special case handling\nAll: Maximum verbosity\nDefault: Default settings\nCode(Expr): Execute custom code\n\n\n\n\n\n","category":"module"},{"location":"api/#Macros","page":"API Reference","title":"Macros","text":"","category":"section"},{"location":"api/#SciMLLogging.@SciMLMessage","page":"API Reference","title":"SciMLLogging.@SciMLMessage","text":"@SciMLMessage(message_or_function, verbose, option, group)\n\nEmit a log message based on verbosity settings.\n\nArguments\n\nmessage_or_function: String message or 0-argument function returning a string\nverbose: An AbstractVerbositySpecifier instance\noption: Symbol for the specific option (e.g., :test1)\ngroup: Symbol for the group containing the option (e.g., :options)\n\nExamples\n\n# String message\n@SciMLMessage(\"Hello\", verbose, :test1, :options)\n\n# Function for lazy evaluation\nx = 10\ny = 20\n@SciMLMessage(verbose, :test1, :options) do\n    z = x + y\n    \"Sum: $z\"\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/#SciMLLogging.verbosity_to_int","page":"API Reference","title":"SciMLLogging.verbosity_to_int","text":"verbosity_to_int(verb::Verbosity.Type)\n\nConvert a Verbosity.Type to an integer.\n\nMapping\n\nNone() → 0\nInfo() → 1\nWarn() → 2\nError() → 3\nLevel(i) → i\n\n\n\n\n\n","category":"function"},{"location":"api/#SciMLLogging.verbosity_to_bool","page":"API Reference","title":"SciMLLogging.verbosity_to_bool","text":"verbosity_to_bool(verb::Verbosity.Type)\n\nConvert a Verbosity.Type to a boolean.\n\nReturns false for Verbosity.None(), true for all other levels.\n\n\n\n\n\n","category":"function"},{"location":"api/#SciMLLogging.SciMLLogger","page":"API Reference","title":"SciMLLogging.SciMLLogger","text":"SciMLLogger(; kwargs...)\n\nCreate a logger that routes messages to REPL and/or files based on log level.\n\nKeyword Arguments\n\ninfo_repl = true: Show info messages in REPL\nwarn_repl = true: Show warnings in REPL\nerror_repl = true: Show errors in REPL\ninfo_file = nothing: File path for info messages\nwarn_file = nothing: File path for warnings\nerror_file = nothing: File path for errors\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"#SciMLLogging.jl","page":"Home","title":"SciMLLogging.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A verbosity control system for the SciML ecosystem that provides fine-grained control over logging and messaging in scientific computing workflows.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fine-grained control: Control individual aspects of logging with specific verbosity settings\nType-safe interface: Leverage Julia's type system for compile-time safety  \nZero-cost abstraction: Disabled verbosity has no runtime overhead\nIntegration with Julia's logging: Built on top of Julia's standard logging infrastructure","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SciMLLogging, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SciMLLogging\")","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use SciMLLogging.jl in your research, please cite the SciML organization:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{SciMLLogging,\n  author = {SciML},\n  title = {SciMLLogging.jl: Verbosity Control for Scientific Machine Learning},\n  url = {https://github.com/SciML/SciMLLogging.jl},\n  version = {v1.0.0},\n}","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Tutorial for a quick introduction to using SciMLLogging.jl.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums for getting help and asking questions:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates how to use SciMLLogging.jl to add verbosity control to your Julia packages.","category":"page"},{"location":"tutorial/#Basic-Concepts","page":"Tutorial","title":"Basic Concepts","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SciMLLogging.jl provides three main components:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Verbosity - A sum type representing different verbosity levels\nAbstractVerbositySpecifier{T} - Base type for custom verbosity types\n@SciMLMessage - Macro for emitting messages based on verbosity settings","category":"page"},{"location":"tutorial/#Creating-a-Verbosity-System","page":"Tutorial","title":"Creating a Verbosity System","text":"","category":"section"},{"location":"tutorial/#Step-1:-Define-Your-Options","page":"Tutorial","title":"Step 1: Define Your Options","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, create a structure to hold your verbosity options:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SciMLLogging\nusing Logging\n\nmutable struct MyOptions\n    startup::Verbosity.Type\n    progress::Verbosity.Type\n    warnings::Verbosity.Type\n    \n    function MyOptions(;\n        startup = Verbosity.Info(),\n        progress = Verbosity.None(),\n        warnings = Verbosity.Warn()\n    )\n        new(startup, progress, warnings)\n    end\nend\nnothing # hide","category":"page"},{"location":"tutorial/#Step-2:-Create-Your-Verbosity-Type","page":"Tutorial","title":"Step 2: Create Your Verbosity Type","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Define a type that inherits from AbstractVerbositySpecifier{T}:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct MyVerbosity{T} <: AbstractVerbositySpecifier{T}\n    options::MyOptions\nend\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The type parameter T determines whether verbosity is enabled:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"T = true: Messages will be processed\nT = false: No runtime overhead (compiled away)","category":"page"},{"location":"tutorial/#Step-3:-Use-the-Verbosity-System","page":"Tutorial","title":"Step 3: Use the Verbosity System","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Create an enabled verbosity instance\nverbose = MyVerbosity{true}(MyOptions())\n\n# Emit messages at different levels\n@SciMLMessage(\"Application starting...\", verbose, :startup, :options)\n@SciMLMessage(\"Processing item 1/100\", verbose, :progress, :options)\n@SciMLMessage(\"Memory usage high\", verbose, :warnings, :options)\nnothing # hide","category":"page"},{"location":"tutorial/#Verbosity-Levels","page":"Tutorial","title":"Verbosity Levels","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SciMLLogging provides several built-in verbosity levels:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SciMLLogging\n\nVerbosity.None()    # No output\nVerbosity.Info()    # Informational messages\nVerbosity.Warn()    # Warning messages\nVerbosity.Error()   # Error messages\nVerbosity.Level(-1000)  # Custom log level with integer n","category":"page"},{"location":"tutorial/#Dynamic-Messages","page":"Tutorial","title":"Dynamic Messages","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use functions for lazy evaluation of expensive message generation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SciMLLogging\nusing Logging\n\n# Define the verbosity system (same as before)\nmutable struct MyOptions2\n    progress::Verbosity.Type\n    MyOptions2() = new(Verbosity.Info())\nend\n\nstruct MyVerbosity2{T} <: AbstractVerbositySpecifier{T}\n    options::MyOptions2\nend\n\nverbose = MyVerbosity2{true}(MyOptions2())\n\n# Variables from surrounding scope\niter = 5\ntotal = 100\n\n@SciMLMessage(verbose, :progress, :options) do\n    percentage = iter / total * 100\n    \"Progress: $iter/$total ($(round(percentage, digits=1))%)\"\nend\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The function is only evaluated if the message will actually be emitted.","category":"page"},{"location":"tutorial/#Disabling-Verbosity","page":"Tutorial","title":"Disabling Verbosity","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For zero runtime cost when disabled:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SciMLLogging\nusing Logging\n\nmutable struct MyOptions3\n    startup::Verbosity.Type\n    MyOptions3() = new(Verbosity.Info())\nend\n\nstruct MyVerbosity3{T} <: AbstractVerbositySpecifier{T}\n    options::MyOptions3\nend\n\n# Disabled verbosity\nsilent = MyVerbosity3{false}(MyOptions3())\n\n# This compiles to nothing - no runtime overhead\n@SciMLMessage(\"This won't be shown\", silent, :startup, :options)\nprintln(\"Message was not shown because verbosity is disabled\")","category":"page"},{"location":"tutorial/#Utility-Functions","page":"Tutorial","title":"Utility Functions","text":"","category":"section"},{"location":"tutorial/#Converting-to-Integer","page":"Tutorial","title":"Converting to Integer","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For compatibility with packages using integer verbosity levels:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SciMLLogging\n\nlevel = verbosity_to_int(Verbosity.Warn())  # Returns 2","category":"page"},{"location":"tutorial/#Converting-to-Boolean","page":"Tutorial","title":"Converting to Boolean","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For packages using boolean verbosity flags:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SciMLLogging\n\nis_verbose = verbosity_to_bool(Verbosity.Info())  # Returns true\nprintln(\"Verbosity.Info() converts to: $is_verbose\")\n\nis_verbose = verbosity_to_bool(Verbosity.None())  # Returns false\nprintln(\"Verbosity.None() converts to: $is_verbose\")","category":"page"},{"location":"tutorial/#Custom-Logger","page":"Tutorial","title":"Custom Logger","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Route messages to different destinations:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SciMLLogging\nusing Logging\n\n# Create a logger that sends warnings and errors to files\nlogger = SciMLLogger(\n    info_repl = true,\n    warn_repl = true,\n    error_repl = true,\n    warn_file = \"warnings.log\",\n    error_file = \"errors.log\"\n)\n\n# Define a simple verbosity system for testing\nmutable struct LoggerTestOptions\n    test::Verbosity.Type\n    LoggerTestOptions() = new(Verbosity.Warn())\nend\n\nstruct LoggerTestVerbosity{T} <: AbstractVerbositySpecifier{T}\n    options::LoggerTestOptions\nend\n\nverbose = LoggerTestVerbosity{true}(LoggerTestOptions())\n\n# Use the logger\nwith_logger(logger) do\n    @SciMLMessage(\"This warning is logged\", verbose, :test, :options)\nend\n\n# Clean up\nisfile(\"warnings.log\") && rm(\"warnings.log\")\nisfile(\"errors.log\") && rm(\"errors.log\")\nnothing # hide","category":"page"},{"location":"tutorial/#Complete-Example","page":"Tutorial","title":"Complete Example","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here's a complete example showing a solver with verbosity:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SciMLLogging\nusing Logging\nusing Random\nRandom.seed!(123) # For reproducibility\n\n# Define verbosity options\nmutable struct SolverOptions\n    initialization::Verbosity.Type\n    iterations::Verbosity.Type\n    convergence::Verbosity.Type\n    \n    function SolverOptions(;\n        initialization = Verbosity.Info(),\n        iterations = Verbosity.None(),\n        convergence = Verbosity.Info()\n    )\n        new(initialization, iterations, convergence)\n    end\nend\n\n# Create verbosity type\nstruct SolverVerbosity{T} <: AbstractVerbositySpecifier{T}\n    options::SolverOptions\nend\n\n# Solver function\nfunction my_solver(problem, verbose::SolverVerbosity)\n    @SciMLMessage(\"Initializing solver...\", verbose, :initialization, :options)\n    \n    for i in 1:100\n        # Do iteration work...\n        \n        @SciMLMessage(verbose, :iterations, :options) do\n            \"Iteration $i: residual = $(round(rand(), digits=4))\"\n        end\n        \n        if rand() < 0.05  # Converged (5% chance per iteration for demo)\n            @SciMLMessage(\"Converged at iteration $i\", verbose, :convergence, :options)\n            return i\n        end\n    end\n    @SciMLMessage(\"Failed to converge\", verbose, :convergence, :options)\n    return nothing\nend\n\n# Use the solver with verbosity\nprintln(\"Running solver with verbosity enabled:\")\nverbose = SolverVerbosity{true}(SolverOptions())\nresult = my_solver(\"problem\", verbose)\nprintln(\"Solver returned: $result\")\n\nprintln(\"\\nRunning solver in silent mode:\")\n# Or with silent mode\nsilent = SolverVerbosity{false}(SolverOptions())\nresult = my_solver(\"problem\", silent)  # No output\nprintln(\"Solver returned: $result (no messages shown)\")","category":"page"},{"location":"tutorial/#Testing-with-Verbosity","page":"Tutorial","title":"Testing with Verbosity","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When testing code that uses SciMLLogging:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SciMLLogging\nusing Logging\nusing Test\n\n# Define a simple verbosity system for testing\nmutable struct TestOptions\n    level::Verbosity.Type\n    TestOptions() = new(Verbosity.Info())\nend\n\nstruct TestVerbosity{T} <: AbstractVerbositySpecifier{T}\n    options::TestOptions\nend\n\n@testset \"Verbosity Tests\" begin\n    verbose = TestVerbosity{true}(TestOptions())\n    \n    # Test that message is logged at correct level\n    @test_logs (:info, \"Test message\") begin\n        @SciMLMessage(\"Test message\", verbose, :level, :options)\n    end\n    \n    # Test that disabled verbosity produces no output\n    silent = TestVerbosity{false}(TestOptions())\n    @test_logs min_level=Logging.Debug begin\n        @SciMLMessage(\"Should not appear\", silent, :level, :options)\n    end\nend","category":"page"}]
}
