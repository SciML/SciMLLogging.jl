var documenterSearchIndex = {"docs":
[{"location":"manual/verbosity_specifiers/#Verbosity-Specifiers","page":"Verbosity Specifiers","title":"Verbosity Specifiers","text":"","category":"section"},{"location":"manual/verbosity_specifiers/","page":"Verbosity Specifiers","title":"Verbosity Specifiers","text":"Verbosity specifiers are the core mechanism for controlling which messages are emitted and at what level. They provide fine-grained control over different categories of output in your applications. These are not provided by the SciMLLogging package, but instead must be implemented by a package wishing to use the SciMLLogging interface. ","category":"page"},{"location":"manual/verbosity_specifiers/#Abstract-Base-Type","page":"Verbosity Specifiers","title":"Abstract Base Type","text":"","category":"section"},{"location":"manual/verbosity_specifiers/#SciMLLogging.AbstractVerbositySpecifier","page":"Verbosity Specifiers","title":"SciMLLogging.AbstractVerbositySpecifier","text":"`AbstractVerbositySpecifier`\n\nBase for types which specify which log messages are emitted at what level.\n\n\n\n\n\n","category":"type"},{"location":"manual/verbosity_specifiers/#Creating-Verbosity-Specifiers","page":"Verbosity Specifiers","title":"Creating Verbosity Specifiers","text":"","category":"section"},{"location":"manual/verbosity_specifiers/","page":"Verbosity Specifiers","title":"Verbosity Specifiers","text":"Package authors typically define their own verbosity specifier types by subtyping AbstractVerbositySpecifier. Each field in the struct represents a different category of messages that can be controlled independently.","category":"page"},{"location":"manual/verbosity_specifiers/#Example-Implementation","page":"Verbosity Specifiers","title":"Example Implementation","text":"","category":"section"},{"location":"manual/verbosity_specifiers/","page":"Verbosity Specifiers","title":"Verbosity Specifiers","text":"using SciMLLogging\nusing ConcreteStructs: @concrete\n\n@concrete struct MyPackageVerbosity <: AbstractVerbositySpecifier\n    initialization    # Controls startup and setup messages\n    progress         # Controls progress and iteration updates\n    convergence      # Controls convergence-related messages\n    diagnostics      # Controls diagnostic messages\n    performance      # Controls performance-related messages\nend","category":"page"},{"location":"manual/verbosity_specifiers/#Using-the-@concrete-Macro","page":"Verbosity Specifiers","title":"Using the @concrete Macro","text":"","category":"section"},{"location":"manual/verbosity_specifiers/","page":"Verbosity Specifiers","title":"Verbosity Specifiers","text":"The @concrete macro from ConcreteStructs.jl is recommended for performance reasons:","category":"page"},{"location":"manual/verbosity_specifiers/","page":"Verbosity Specifiers","title":"Verbosity Specifiers","text":"Type stability: Eliminates type instabilities that can hurt performance\nCompile-time optimization: Allows the compiler to generate more efficient code\nZero-cost abstraction: Disabled verbosity ideally incurs no runtime ","category":"page"},{"location":"manual/verbosity_specifiers/#Configuring-Message-Categories","page":"Verbosity Specifiers","title":"Configuring Message Categories","text":"","category":"section"},{"location":"manual/verbosity_specifiers/","page":"Verbosity Specifiers","title":"Verbosity Specifiers","text":"Each field in a verbosity specifier can be set to any AbstractMessageLevel:","category":"page"},{"location":"manual/verbosity_specifiers/","page":"Verbosity Specifiers","title":"Verbosity Specifiers","text":"# Create a custom configuration\ncustom_verbosity = MyPackageVerbosity(\n    initialization = InfoLevel(),     # Show startup information\n    progress = Silent(),             # Hide progress updates\n    convergence = InfoLevel(),        # Show convergence status\n    diagnostics = WarnLevel(),       # Show diagnostic messages\n    performance = InfoLevel()        # Show performance info\n)","category":"page"},{"location":"manual/verbosity_specifiers/#Integration-with-Packages","page":"Verbosity Specifiers","title":"Integration with Packages","text":"","category":"section"},{"location":"manual/verbosity_specifiers/","page":"Verbosity Specifiers","title":"Verbosity Specifiers","text":"Package authors should provide verbosity arguments in their main functions:","category":"page"},{"location":"manual/verbosity_specifiers/","page":"Verbosity Specifiers","title":"Verbosity Specifiers","text":"function solve_problem(problem; verbose = MyPackageVerbosity(Standard()), kwargs...)\n    @SciMLMessage(\"Starting computation\", verbose, :initialization)\n\n    for i in 1:max_iterations\n        @SciMLMessage(\"Iteration $i\", verbose, :progress)\n\n        # ... computation ...\n\n        if converged\n            @SciMLMessage(\"Converged after $i iterations\", verbose, :convergence)\n            break\n        end\n    end\n\n    return result\nend","category":"page"},{"location":"manual/macro/#The-@SciMLMessage-Macro","page":"@SciMLMessage Macro","title":"The @SciMLMessage Macro","text":"","category":"section"},{"location":"manual/macro/","page":"@SciMLMessage Macro","title":"@SciMLMessage Macro","text":"The @SciMLMessage macro is the primary interface for emitting log messages in the SciMLLogging system. It allows you to emit messages that are controlled by verbosity specifiers.","category":"page"},{"location":"manual/macro/#SciMLLogging.@SciMLMessage","page":"@SciMLMessage Macro","title":"SciMLLogging.@SciMLMessage","text":"`@SciMLMessage(message, verbosity::AbstracVerbositySpecifier, option::Symbol)`\n`@SciMLMessage(message, verbosity::Bool)`\n\nA macro that emits a log message based on the log level specified in the option of the AbstractVerbositySpecifier supplied.\n\nf_or_message may be a message String, or a 0-argument function that returns a String.\n\nUsage\n\nTo emit a simple string, @SciMLMessage(\"message\", verbosity, :option) will emit a log message with the LogLevel specified in verbosity for the given option.\n\n@SciMLMessage can also be used to emit a log message coming from the evaluation of a 0-argument function. This function is resolved in the environment of the macro call. Therefore it can use variables from the surrounding environment. This may be useful if the log message writer wishes to carry out some calculations using existing variables and use them in the log message. The function is only called if the message category is not Silent(), avoiding unnecessary computation.\n\nThe macro works with any AbstractVerbositySpecifier implementation:\n\n# Package defines verbosity specifier\n@concrete struct SolverVerbosity <: AbstractVerbositySpecifier\n    initialization\n    progress\n    convergence\n    diagnostics\n    performance\nend\n\n# Usage in package code\nfunction solve_problem(problem; verbose = SolverVerbosity(Standard()))\n    @SciMLMessage(\"Initializing solver\", verbose, :initialization)\n\n    # ... solver setup ...\n\n    for iteration in 1:max_iterations\n        @SciMLMessage(\"Iteration $iteration\", verbose, :progress)\n\n        # ... iteration work ...\n\n        if converged\n            @SciMLMessage(\"Converged after $iteration iterations\", verbose, :convergence)\n            break\n        end\n    end\n\n    return result\nend\n\nAlternatively, the macro also accepts a boolean value for verb:\n\nWhen verb is a boolean:\n\ntrue will emit the message at WarnLevel()\nfalse will suppress the message (equivalent to Silent())\n\nThe two-argument form @SciMLMessage(message, verbosity) can be used when verbosity is a Bool:\n\nfunction solve_problem(problem; verbose::Bool = true)\n    @SciMLMessage(\"Starting solver\", verbose)\n    # ... solver logic ...\nend\n\n\n\n\n\n","category":"macro"},{"location":"getting_started/#Getting-Started-with-SciMLLogging.jl","page":"Getting Started","title":"Getting Started with SciMLLogging.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide will help you get up and running with SciMLLogging.jl quickly. SciMLLogging provides fine-grained verbosity control for scientific computing workflows in Julia.","category":"page"},{"location":"getting_started/#Basic-Concepts","page":"Getting Started","title":"Basic Concepts","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"SciMLLogging.jl is built around three core concepts:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Message Levels: Define the importance of messages (Silent(), InfoLevel(), WarnLevel(), ErrorLevel())\nVerbosity Specifiers: Control which categories of messages are shown and at what level\nVerbosity Presets: Predefined settings for common use cases (None(), Minimal(), Standard(), Detailed(), All())","category":"page"},{"location":"getting_started/#Quick-Start-with-Presets","page":"Getting Started","title":"Quick Start with Presets","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The easiest way to get started is with verbosity presets. Most packages that use SciMLLogging will provide these options:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using SciMLLogging\n\n# Use presets for quick setup (assuming MyPackageVerbosity from a package)\nnone_verbose = MyPackageVerbosity(None())      # No output (best for production)\nminimal_verbose = MyPackageVerbosity(Minimal()) # Only essential messages\nstandard_verbose = MyPackageVerbosity(Standard()) # Balanced output (recommended)\ndetailed_verbose = MyPackageVerbosity(Detailed()) # Comprehensive output for debugging\nall_verbose = MyPackageVerbosity(All())        # Maximum verbosity\n\n# Use in your code\nresult = solve(problem, verbose = standard_verbose)","category":"page"},{"location":"getting_started/#Custom-Configuration","page":"Getting Started","title":"Custom Configuration","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For more control, packages typically allow you to configure individual message categories:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Custom configuration\ncustom_verbose = MyPackageVerbosity(\n    startup = InfoLevel(),      # Show startup messages\n    progress = Silent(),        # Hide progress updates\n    diagnostics = WarnLevel(),  # Show diagnostic warnings\n    performance = InfoLevel()   # Show performance info\n)\n\nresult = solve(problem, verbose = custom_verbose)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Message Levels:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Silent(): No output for this category\nDebugLevel(): Lowest priority messages\nInfoLevel(): Informational messages\nWarnLevel(): Warning messages\nErrorLevel(): Error messages\nCustomLevel(n): Custom level with integer value","category":"page"},{"location":"getting_started/#Logging-Backends","page":"Getting Started","title":"Logging Backends","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"By default, SciMLLogging integrates with Julia's standard logging system, but there is also a backend that uses Core.println to emit messages. This is configurable via a Preferences.jl preference setting.","category":"page"},{"location":"getting_started/#Standard-Julia-Logging-(Default)","page":"Getting Started","title":"Standard Julia Logging (Default)","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Logging\n\n# Use with Julia's built-in loggers\nwith_logger(ConsoleLogger(stdout, Logging.Info)) do\n    # Your code here with verbose output\n    run_simulation(verbose = standard_verbose)\nend","category":"page"},{"location":"getting_started/#Simple-Console-Output","page":"Getting Started","title":"Simple Console Output","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For simpler output without the logging infrastructure:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Switch to simple println-style output (r)\nSciMLLogging.set_logging_backend(\"core\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This makes the logging compatible with binary building via JuliaC and reduces the overhead. ","category":"page"},{"location":"getting_started/#Switching-Back","page":"Getting Started","title":"Switching Back","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To switch back to using the logging infrastructure:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"SciMLLogging.set_logging_backend(\"logging\")","category":"page"},{"location":"getting_started/#Saving-Output-to-Files","page":"Getting Started","title":"Saving Output to Files","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Combine with Julia's logging to save output:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Logging\n\n# Save all output to a file\nopen(\"computation_log.txt\", \"w\") do io\n    with_logger(SimpleLogger(io)) do\n        result = long_computation(verbose = MyPackageVerbosity(Standard()))\n    end\nend\n\n# Or use SciMLLogger for more control\nlogger = SciMLLogger(\n    info_file = \"info.log\",\n    warn_file = \"warnings.log\",\n    error_file = \"errors.log\"\n)\n\nwith_logger(logger) do\n    result = computation(verbose = MyPackageVerbosity(Detailed()))\nend","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For end users: See the User Tutorial: Configuring Package Verbosity for detailed information about controlling package verbosity\nFor package developers: Check the Developer Tutorial: Adding SciMLLogging to Your Package to learn how to integrate SciMLLogging into your packages","category":"page"},{"location":"getting_started/#Getting-Help","page":"Getting Started","title":"Getting Help","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you encounter issues:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Check package-specific documentation for their verbosity settings\nUse maximum verbosity (All()) to see what's happening\nConsult the Julia logging documentation for advanced output control\nVisit the SciML Community page for support","category":"page"},{"location":"manual/presets/#Verbosity-Presets","page":"Verbosity Presets","title":"Verbosity Presets","text":"","category":"section"},{"location":"manual/presets/","page":"Verbosity Presets","title":"Verbosity Presets","text":"Presets provide convenient, predefined verbosity configurations that cover common use cases. Instead of manually setting each message category, users can choose from standard presets that automatically configure appropriate message levels. SciMLLogging provides the AbstractVerbosityPreset type, along with five subtypes meant to represent different verbosity levels. It is up to the implementer of the AbstractVerbositySpecifier to ensure that the verbosity presets are able to be used.  ","category":"page"},{"location":"manual/presets/#General-Idea-of-Preset-Levels","page":"Verbosity Presets","title":"General Idea of Preset Levels","text":"","category":"section"},{"location":"manual/presets/#Definition-of-the-Preset-Levels","page":"Verbosity Presets","title":"Definition of the Preset Levels","text":"","category":"section"},{"location":"manual/presets/","page":"Verbosity Presets","title":"Verbosity Presets","text":"The general idea behind the preset levels is as follows. Each lower level keeps everything enabled from the level above it, and adds the additional information:","category":"page"},{"location":"manual/presets/","page":"Verbosity Presets","title":"Verbosity Presets","text":"None makes it easy to turn off all printing/logging to ensure 0 overhead and 0 noise.\nMinimal turns on only the fatal errors, for example solvers exiting early due to instability, which the user must react to in order to appropriately compute correctly.\nStandard turns on non-fatal but critical warnings, for example major performance warnings or deprecations which have been flagged that the user almost certaintly should respond to. While the program is still running correctly if these are firing, this is the level on by default to signal to the wider userbase issues which should be handled in order to have \"normal\" running code.\nDetailed turns on additional information as part of the run which can be helpful for in-depth debugging. This includes information about critical quantities at each step of the calculation, behaviors of the solver that are chosen behind the scenes, and critical numerical issues which are detected. This level should be detailed, but it should be something that does not necessarily overflow the standard REPL output and should not introduce major performance overhead.\nAll turns on all logging available in the system. This can include detailed printing that happens in every iteration (i.e. overflowing the terminal output maximum lines), expensive calculations of critical quantities like condition numbers which can be more expensive than the standard solver but serve as good diagnostics to understand the numerical quantities better, and other verbose output which could be found interesting to package developers looking for obscure issues. It is generally recommended that All output is redirected to a file as it likely will need to be parsed to be human understandable.","category":"page"},{"location":"manual/presets/#Preset-Level-Examples","page":"Verbosity Presets","title":"Preset Level Examples","text":"","category":"section"},{"location":"manual/presets/","page":"Verbosity Presets","title":"Verbosity Presets","text":"In the ODE solver, if dt<dtmin the solver needs to exit. Almost all users should be notified of this behavior in order to understand why the solver did not go to the final time. This should be set as a WarnLevel in the Minimal preset.\nIn LinearSolve.jl's default methods, it has the ability to swap from using an LU factorization to a column-pivoted QR factorization behind the scenes if a singular matrix is detected. Since LinearSolve.jl automatically recovers from any error here, most users do not need to know if this has happened, thus it is a solver behavoir that should be logged at the Detailed level because it's non-verbose and no extra cost to know, but can be a critical debugging information.\nIn SciMLSensitivity.jl's default vjp method, it has to run through a bunch of different potential reverse-mode AD methods to see which is compatible with the user's f. If none of the AD methods are compatible, it needs to fallback to FiniteDiffVJP, which is finite differencing and thus changes the J'v calcuation from O(n) matrix-free to O(n^2) building J. This is a massive difference in computational cost which most users should know about, as it should generally be considered incorrect behavior to require finite differencing here and the user should be notified by default about this fallback. Thus it should be given WarnLevel in the Standard preset, since it's not critical so it's not Minimal. In the Detailed preset, the vjp choice should additionally be shared every time even if it's not finite differencing.\nIn LinearSolve.jl, it can be very useful to know cond(A) in order to know how ill-conditioned the numerical problem is at every step. This can help for understanding why Newton-Krylov methods aren't converging well, or whether ODE solves should have difficulties handling a given step. However, cond(A) is a very expensive calculation, sometimes more expensive than the solver itself, and thus it should only be enabled when maximum information is needed. Thus this printing would only be enabled when All is chosen.\nThe default ODE solver has the ability to automatically swap between solvers based on certain qualities of the ODE that are detected, essentially estimating condition number. While this behavior is not necessary for most users to know, it can help a lot while debugging to know exactly when the swaps occured. Since they don't occur often, this information should be included in the Detailed output, along with some information about why the trigger occurred.\nError estimate values of adaptive ODE solvers, eigenvalue estimates in stabilized RK (RKC) methods, and other per-step estimators can be really useful for debugging ODE solvers in order to know what specific term  is likely making the solver drop the dt to be smaller, but it's very noisy to print tons of information at every step. Thus this information can be setup to have standard printers which are only turned on by demand or in the All preset.","category":"page"},{"location":"manual/presets/#Abstract-Base-Type","page":"Verbosity Presets","title":"Abstract Base Type","text":"","category":"section"},{"location":"manual/presets/#SciMLLogging.AbstractVerbosityPreset","page":"Verbosity Presets","title":"SciMLLogging.AbstractVerbosityPreset","text":"AbstractVerbosityPreset\n\nAbstract base type for predefined verbosity configurations.\n\nPresets provide convenient ways for users to configure verbosity without needing to specify individual message categories. Concrete subtypes include:\n\nNone: Disable all verbosity\nMinimal: Only essential messages\nStandard: Balanced verbosity for typical use\nDetailed: Comprehensive verbosity for debugging\nAll: Enable all message categories\n\n\n\n\n\n","category":"type"},{"location":"manual/presets/#Available-Presets","page":"Verbosity Presets","title":"Available Presets","text":"","category":"section"},{"location":"manual/presets/#SciMLLogging.None","page":"Verbosity Presets","title":"SciMLLogging.None","text":"None <: AbstractVerbosityPreset\n\nPreset that disables all verbosity. All message categories should be set to to Silent().\n\n\n\n\n\n","category":"type"},{"location":"manual/presets/#SciMLLogging.Minimal","page":"Verbosity Presets","title":"SciMLLogging.Minimal","text":"Minimal <: AbstractVerbosityPreset\n\nPreset that shows only essential messages. Typically includes only warnings, errors, and critical status information while suppressing routine progress and debugging messages. \n\nThis verbosity preset should set messages related to critical failures and  errors that stop computation to ErrorLevel. Messages related to fatal issues  (e.g., convergence problems, solver exiting, etc.) should be set to WarnLevel().  All other messages should be set to Silent().\n\n\n\n\n\n","category":"type"},{"location":"manual/presets/#SciMLLogging.Standard","page":"Verbosity Presets","title":"SciMLLogging.Standard","text":"Standard <: AbstractVerbosityPreset\n\nPreset that provides balanced verbosity suitable for typical usage. Shows important progress and status information without overwhelming the user with details.\n\nThis verbosity preset should include the settings from Minimal, while also setting  messages such as non-fatal deprecations and critical warnings that require handling  to InfoLevel.\n\n\n\n\n\n","category":"type"},{"location":"manual/presets/#SciMLLogging.Detailed","page":"Verbosity Presets","title":"SciMLLogging.Detailed","text":"Detailed <: AbstractVerbosityPreset\n\nPreset that provides comprehensive verbosity for debugging and detailed analysis. Shows most or all available message categories to help with troubleshooting and understanding program behavior.\n\nThis verbosity preset should include the settings from Standard, plus progress updates  (e.g., iteration counters, intermediate state), performance metrics  (e.g., timing information, memory usage), detailed diagnostics, and internal state information. The only messages that should be Silent() at this preset are very small details that would  clutter output even during debugging, and information that would be expensive to calculate.\n\n\n\n\n\n","category":"type"},{"location":"manual/presets/#SciMLLogging.All","page":"Verbosity Presets","title":"SciMLLogging.All","text":"All <: AbstractVerbosityPreset\n\nPreset that enables maximum verbosity. All message categories are typically set to show informational messages or their appropriate levels.\n\nThis verbosity preset should include the settings from Detailed, plus even more details. At this preset, no messages should be Silent(). \n\n\n\n\n\n","category":"type"},{"location":"manual/presets/#Custom-Presets","page":"Verbosity Presets","title":"Custom Presets","text":"","category":"section"},{"location":"manual/presets/","page":"Verbosity Presets","title":"Verbosity Presets","text":"Packages can define their own preset types for specialized use cases:","category":"page"},{"location":"manual/presets/","page":"Verbosity Presets","title":"Verbosity Presets","text":"# Package-specific preset\nstruct DebuggingPreset <: AbstractVerbosityPreset end\n\nfunction MyPackageVerbosity(::DebuggingPreset)\n    MyPackageVerbosity{true}(\n        initialization = InfoLevel(),\n        progress = DebugLevel(),  # Extra detailed progress\n        convergence = InfoLevel(),\n        warnings = WarnLevel(),\n        errors = ErrorLevel()\n    )\nend","category":"page"},{"location":"manual/presets/#Using-Presets","page":"Verbosity Presets","title":"Using Presets","text":"","category":"section"},{"location":"manual/presets/","page":"Verbosity Presets","title":"Verbosity Presets","text":"Presets are typically used as constructor arguments for verbosity specifiers:","category":"page"},{"location":"manual/presets/","page":"Verbosity Presets","title":"Verbosity Presets","text":"using SciMLLogging\n\n# Assuming a package defines MyPackageVerbosity\nquiet_config = MyPackageVerbosity(None())      # No output\ndefault_config = MyPackageVerbosity(Standard()) # Balanced output\ndebug_config = MyPackageVerbosity(All())       # Maximum output","category":"page"},{"location":"manual/presets/#How-Presets-Work","page":"Verbosity Presets","title":"How Presets Work","text":"","category":"section"},{"location":"manual/presets/","page":"Verbosity Presets","title":"Verbosity Presets","text":"When you pass a preset to a verbosity specifier constructor, the package implementation maps the preset to appropriate message levels for each category. For example:","category":"page"},{"location":"manual/presets/","page":"Verbosity Presets","title":"Verbosity Presets","text":"# This preset usage...\nverbosity = SolverVerbosity(Standard())\n\n# ...might be equivalent to this manual configuration:\nverbosity = SolverVerbosity(\n    initialization = InfoLevel(),\n    progress = Silent(),\n    convergence = InfoLevel(),\n    diagnostics = WarnLevel(),\n    performance = InfoLevel()\n)","category":"page"},{"location":"manual/message_levels/#Message-Levels","page":"Message Levels","title":"Message Levels","text":"","category":"section"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"Message levels in SciMLLogging determine the severity and importance of log messages. Understanding these levels is essential for configuring appropriate verbosity in your applications.","category":"page"},{"location":"manual/message_levels/#Overview","page":"Message Levels","title":"Overview","text":"","category":"section"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"SciMLLogging provides a hierarchy of message levels that correspond to different types of information:","category":"page"},{"location":"manual/message_levels/#SciMLLogging.AbstractMessageLevel","page":"Message Levels","title":"SciMLLogging.AbstractMessageLevel","text":"AbstractMessageLevel\n\nAbstract base type for all verbosity log levels in SciMLLogging.\n\nLog levels determine the severity/importance of messages. Concrete subtypes include:\n\nSilent: No output\nDebugLevel: Debug messages\nInfoLevel: Informational messages\nWarnLevel: Warning messages\nErrorLevel: Error messages\nCustomLevel(n): Custom log level with integer value n\n\n\n\n\n\n","category":"type"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"Each of the AbstractMessageLevels correspond to a Julia Logging LogLevel type with an associated integer, besides Silent.  See the Julia Logging documentation for more details. ","category":"page"},{"location":"manual/message_levels/#Standard-Message-Levels","page":"Message Levels","title":"Standard Message Levels","text":"","category":"section"},{"location":"manual/message_levels/#Silent-Level","page":"Message Levels","title":"Silent Level","text":"","category":"section"},{"location":"manual/message_levels/#SciMLLogging.Silent","page":"Message Levels","title":"SciMLLogging.Silent","text":"Silent <: AbstractMessageLevel\n\nLog level that produces no output. When a message category is set to Silent(), no messages will be emitted for that category.\n\n\n\n\n\n","category":"type"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"The Silent level is special - it completely suppresses output for a message. As such, it does not have an associated LogLevel.","category":"page"},{"location":"manual/message_levels/#Debug-Level","page":"Message Levels","title":"Debug Level","text":"","category":"section"},{"location":"manual/message_levels/#SciMLLogging.DebugLevel","page":"Message Levels","title":"SciMLLogging.DebugLevel","text":"DebugLevel <: AbstractMessageLevel\n\nDebug log level. Messages at this level provide detailed debugging information, typically more verbose than informational messages. Useful for development and troubleshooting. \n\nCorresponds to Logging.Debug == Logging.LogLevel(-1000) when using the Logging backend.\n\nBy default, these messages are not logged at all, and the  JULIA_DEBUG environment variable needs to be set. For details see the Julia Logging documentation.\n\n\n\n\n\n","category":"type"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"DebugLevel() is for messages with a very low priority.  By default, these messages are not logged at all, and the JULIA_DEBUG environment variable needs to be set. For details see the Julia Logging documentation. ","category":"page"},{"location":"manual/message_levels/#Information-Level","page":"Message Levels","title":"Information Level","text":"","category":"section"},{"location":"manual/message_levels/#SciMLLogging.InfoLevel","page":"Message Levels","title":"SciMLLogging.InfoLevel","text":"InfoLevel <: AbstractMessageLevel\n\nInformational log level. Messages at this level provide general information about the progress or state of the computation. \n\nCorresponds to Logging.Info == Logging.LogLevel(0) when using the Logging backend.\n\n\n\n\n\n","category":"type"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"Use InfoLevel() for general status updates, progress information, and routine diagnostic messages that users might want to see during normal operation.","category":"page"},{"location":"manual/message_levels/#Warning-Level","page":"Message Levels","title":"Warning Level","text":"","category":"section"},{"location":"manual/message_levels/#SciMLLogging.WarnLevel","page":"Message Levels","title":"SciMLLogging.WarnLevel","text":"WarnLevel <: AbstractMessageLevel\n\nWarning log level. Messages at this level indicate potential issues or situations that may require attention but don't prevent execution.\n\nCorresponds to Logging.Warn == Logging.LogLevel(1000) when using the Logging backend.\n\n\n\n\n\n","category":"type"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"WarnLevel() should be used for potentially problematic situations that don't prevent execution but may require user attention.","category":"page"},{"location":"manual/message_levels/#Error-Level","page":"Message Levels","title":"Error Level","text":"","category":"section"},{"location":"manual/message_levels/#SciMLLogging.ErrorLevel","page":"Message Levels","title":"SciMLLogging.ErrorLevel","text":"ErrorLevel <: AbstractMessageLevel\n\nError log level. Messages at this level indicate serious problems or failures in the computation.\n\nCorresponds to Logging.Warn == Logging.LogLevel(2000) when using the Logging backend.\n\n\n\n\n\n","category":"type"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"ErrorLevel() is reserved for serious problems and failures that indicate something has gone wrong in the computation.","category":"page"},{"location":"manual/message_levels/#Custom-Message-Levels","page":"Message Levels","title":"Custom Message Levels","text":"","category":"section"},{"location":"manual/message_levels/#SciMLLogging.CustomLevel","page":"Message Levels","title":"SciMLLogging.CustomLevel","text":"CustomLevel(n::Int) <: AbstractMessageLevel\n\nCustom log level with integer value n. This allows creating custom severity levels beyond the standard Info/Warn/Error hierarchy.\n\nCorresponds to Logging.LogLevel(n), where n is any integer, when using the Logging backend.\n\nHigher integer values typically indicate higher priority/severity.\n\nExample\n\ndebug_level = CustomLevel(-1000)  # Very low priority debug messages\ncritical_level = CustomLevel(1000)  # Very high priority critical messages\n\n\n\n\n\n","category":"type"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"Custom levels provide flexibility for specialized use cases where the standard Info/Warn/Error hierarchy isn't sufficient.","category":"page"},{"location":"manual/message_levels/#Usage-Examples","page":"Message Levels","title":"Usage Examples","text":"","category":"section"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"using SciMLLogging\n\n# Standard levels\ndebug_level = DebugLevel()\ninfo_level = InfoLevel()\nwarn_level = WarnLevel()\nerror_level = ErrorLevel()\nsilent_level = Silent()\n\n# Custom levels for specialized needs\ntrace_level = CustomLevel(-500)     # Low priority debugging\ncritical_level = CustomLevel(2000)  # Higher than standard error level","category":"page"},{"location":"manual/message_levels/#Level-Hierarchy","page":"Message Levels","title":"Level Hierarchy","text":"","category":"section"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"The message levels have a natural hierarchy that affects logging behavior:","category":"page"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"Silent(): No output (always suppressed)\nDebugLevel(): Lowest priority message\nInfoLevel(): Low priority for general information\nWarnLevel(): Medium priority\nErrorLevel(): Highest standard priority\nCustomLevel(n): Priority determined by integer value n","category":"page"},{"location":"manual/message_levels/","page":"Message Levels","title":"Message Levels","text":"Higher priority messages are more likely to be displayed by logging systems, while lower priority messages may be filtered out depending on the logger configuration.","category":"page"},{"location":"manual/backends/#Logging-Backends","page":"Logging Backends","title":"Logging Backends","text":"","category":"section"},{"location":"manual/backends/","page":"Logging Backends","title":"Logging Backends","text":"SciMLLogging supports two output backends: Julia's standard logging system (default) and simple console output.","category":"page"},{"location":"manual/backends/#Backend-Configuration","page":"Logging Backends","title":"Backend Configuration","text":"","category":"section"},{"location":"manual/backends/#SciMLLogging.set_logging_backend","page":"Logging Backends","title":"SciMLLogging.set_logging_backend","text":"`set_logging_backend(backend::String)``\n\nSet the logging backend preference. Valid options are:\n\n\"logging\": Use Julia's standard Logging system (default)\n\"core\": Use Core.println for simple output\n\nNote: You must restart Julia for this preference change to take effect.\n\n\n\n\n\n","category":"function"},{"location":"manual/backends/#SciMLLogging.get_logging_backend","page":"Logging Backends","title":"SciMLLogging.get_logging_backend","text":"`get_logging_backend()`\n\nGet the current logging backend preference.\n\n\n\n\n\n","category":"function"},{"location":"manual/backends/","page":"Logging Backends","title":"Logging Backends","text":"Switch between backends:","category":"page"},{"location":"manual/backends/","page":"Logging Backends","title":"Logging Backends","text":"# Switch to simple console output\nset_logging_backend(\"core\")\n\n# Switch back to standard logging (default)\nset_logging_backend(\"logging\")","category":"page"},{"location":"manual/backends/","page":"Logging Backends","title":"Logging Backends","text":"Note: Restart Julia after changing backends.","category":"page"},{"location":"manual/backends/#Standard-Logging-Backend","page":"Logging Backends","title":"Standard Logging Backend","text":"","category":"section"},{"location":"manual/backends/","page":"Logging Backends","title":"Logging Backends","text":"Uses Julia's Logging system. Messages integrate with loggers and can be filtered or redirected using standard filters or other packages that integrate with the logging system, e.g. LoggingExtras.jl.","category":"page"},{"location":"manual/backends/","page":"Logging Backends","title":"Logging Backends","text":"using Logging\n\n# Route to console\nwith_logger(ConsoleLogger(stdout, Logging.Info)) do\n    result = solve(problem, verbose = SolverVerbosity(Standard()))\nend\n\n# Route to file\nopen(\"output.log\", \"w\") do io\n    with_logger(SimpleLogger(io)) do\n        result = solve(problem, verbose = SolverVerbosity(Detailed()))\n    end\nend","category":"page"},{"location":"manual/backends/#Core-Backend","page":"Logging Backends","title":"Core Backend","text":"","category":"section"},{"location":"manual/backends/","page":"Logging Backends","title":"Logging Backends","text":"Uses Core.println for direct console output. Simpler but less flexible. This allows messages to emitted, while still being compatible with static compilation and JuliaC. ","category":"page"},{"location":"manual/backends/#SciMLLogger","page":"Logging Backends","title":"SciMLLogger","text":"","category":"section"},{"location":"manual/backends/#SciMLLogging.SciMLLogger","page":"Logging Backends","title":"SciMLLogging.SciMLLogger","text":"SciMLLogger(; kwargs...)\n\nCreate a logger that routes messages to REPL and/or files based on log level.\n\nKeyword Arguments\n\ndebug_repl = false: Show debug messages in REPL\ninfo_repl = true: Show info messages in REPL\nwarn_repl = true: Show warnings in REPL\nerror_repl = true: Show errors in REPL\ndebug_file = nothing: File path for debug messages\ninfo_file = nothing: File path for info messages\nwarn_file = nothing: File path for warnings\nerror_file = nothing: File path for errors\n\n\n\n\n\n","category":"function"},{"location":"manual/backends/","page":"Logging Backends","title":"Logging Backends","text":"Convenient logger that routes messages by level:","category":"page"},{"location":"manual/backends/","page":"Logging Backends","title":"Logging Backends","text":"# Route info to file, warnings/errors to console and file\nlogger = SciMLLogger(\n    info_repl = false,\n    info_file = \"info.log\",\n    warn_file = \"warnings.log\",\n    error_file = \"errors.log\"\n)\n\nwith_logger(logger) do\n    result = solve(problem, verbose = SolverVerbosity(Standard()))\nend","category":"page"},{"location":"tutorials/developer_tutorial/#Developer-Tutorial:-Adding-SciMLLogging-to-Your-Package","page":"Developer Guide","title":"Developer Tutorial: Adding SciMLLogging to Your Package","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"This tutorial is for Julia package developers who want to integrate SciMLLogging.jl into their packages to provide users with fine-grained verbosity control.","category":"page"},{"location":"tutorials/developer_tutorial/#Overview","page":"Developer Guide","title":"Overview","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"SciMLLogging.jl provides four main components for package developers:","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"AbstractVerbositySpecifier - Base type for creating custom verbosity types\n@SciMLMessage - Macro for emitting conditional log messages\nLog levels - Predefined log levels (Silent, DebugLevel, InfoLevel, WarnLevel, ErrorLevel, CustomLevel(n)). These are the fields of the AbstractVerbositySpecifiers that determine which messages get logged, and at what log level. \nVerbosity preset levels - None, Minimal, Standard, Detailed, All. These represent predefined sets of log levels. ","category":"page"},{"location":"tutorials/developer_tutorial/#AbstractVerbositySpecifier","page":"Developer Guide","title":"AbstractVerbositySpecifier","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"`AbstractVerbositySpecifier` is the base type that package developers implement a subtype of to create custom verbosity type for their packages.","category":"page"},{"location":"tutorials/developer_tutorial/#@SciMLMessage","page":"Developer Guide","title":"@SciMLMessage","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"In order to use the the @SciMLMessage macro, simply choose which of the fields of your AbstractVerbositySpecifier should control that particular message. Then when the macro is called, the field of the verbosity object corresponding with the option argument to the macro is used to control the logging of the message. ","category":"page"},{"location":"tutorials/developer_tutorial/#Step-1:-Design-Your-Verbosity-Interface","page":"Developer Guide","title":"Step 1: Design Your Verbosity Interface","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"First, decide what aspects of your package should be controllable by users. For example, a solver might have:","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"Initialization messages\nIteration progress\nConvergence information\nError control information","category":"page"},{"location":"tutorials/developer_tutorial/#Step-2:-Create-Your-Verbosity-Type","page":"Developer Guide","title":"Step 2: Create Your Verbosity Type","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"Define a struct that subtypes AbstractVerbositySpecifier:","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"using SciMLLogging\nusing ConcreteStructs: @concrete\n\n@concrete struct MySolverVerbosity <: AbstractVerbositySpecifier\n    initialization\n    iterations\n    convergence\n    warnings\nend\n\n# Constructor with defaults\nfunction MySolverVerbosity(;\n        initialization = InfoLevel(),\n        iterations = Silent(),\n        convergence = InfoLevel(),\n        warnings = WarnLevel()\n)\n    MySolverVerbosity(initialization, iterations, convergence, warnings)\nend","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"Use @concrete from ConcreteStructs.jl for better performance\nEach field represents a category of messages your package can emit","category":"page"},{"location":"tutorials/developer_tutorial/#Step-3:-Add-Convenience-Constructors","page":"Developer Guide","title":"Step 3: Add Convenience Constructors","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"Make it easy for users to create verbosity instances. Perhaps include a constructor that can take a AbstractVerbosityPreset, and use it to set the rest of the fields, and a constructor that takes all keyword arguments:","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"# Preset-based constructor (optional)\nfunction MySolverVerbosity(preset::AbstractVerbosityPreset)\n    if preset isa None\n        MySolverVerbosity(\n            initialization = Silent(),\n            iterations = Silent(),\n            convergence = Silent(),\n            warnings = Silent()\n        )\n    elseif preset isa All\n        MySolverVerbosity(\n            initialization = InfoLevel(),\n            iterations = InfoLevel(),\n            convergence = InfoLevel(),\n            error_control = WarnLevel()\n        )\n    elseif preset isa Minimal\n        MySolverVerbosity(\n            initialization = Silent(),\n            iterations = Silent(),\n            convergence = ErrorLevel(),\n            error_control = ErrorLevel()\n        )\n    else\n        MySolverVerbosity()  # Default\n    end\nend","category":"page"},{"location":"tutorials/developer_tutorial/#Step-4:-Integrate-Messages-Into-Your-Code","page":"Developer Guide","title":"Step 4: Integrate Messages Into Your Code","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"Use @SciMLMessage throughout your package code:","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"function my_solve(problem, verbose::MySolverVerbosity)\n    @SciMLMessage(\"Initializing solver for $(typeof(problem))\", verbose, :initialization)\n\n    # Setup code here...\n\n    for iteration in 1:maxiters\n        # Solver iteration...\n\n        @SciMLMessage(verbose, :iterations) do\n            \"Iteration $iteration: residual = $(compute_residual())\"\n        end\n\n        if converged\n            @SciMLMessage(\"Converged after $iteration iterations\", verbose, :convergence)\n            return solution\n        end\n\n        if should_warn_about_something()\n            @SciMLMessage(\"Convergence is slow, consider adjusting parameters\", verbose, :error_control)\n        end\n    end\n\n    @SciMLMessage(\"Failed to converge after $maxiters iterations\", verbose, :convergence)\n    return nothing\nend","category":"page"},{"location":"tutorials/developer_tutorial/#Step-5:-Document-for-Users","page":"Developer Guide","title":"Step 5: Document for Users","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"Provide clear documentation for your users:","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"\n    MySolverVerbosity(; kwargs...)\n\nControls verbosity output from MySolver functions.\n\n# Keyword Arguments\n- `initialization = InfoLevel()`: Messages about solver setup\n- `iterations = Silent()`: Per-iteration progress messages\n- `convergence = InfoLevel()`: Convergence/failure notifications\n- `error_control = WarnLevel()`: Messages about solver error control\n\n# Constructors\n- `MySolverVerbosity()`: Default enabled verbosity\n- `MySolverVerbosity(None())`: Disabled (zero overhead)\n- `MySolverVerbosity(All())`: Enable all message categories\n- `MySolverVerbosity(Minimal())`: Only errors and convergence\n\n# Example","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"julia","category":"page"},{"location":"tutorials/developer_tutorial/#Default-verbosity","page":"Developer Guide","title":"Default verbosity","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"verbose = MySolverVerbosity()","category":"page"},{"location":"tutorials/developer_tutorial/#Custom-verbosity-show-everything-except-iterations","page":"Developer Guide","title":"Custom verbosity - show everything except iterations","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"verbose = MySolverVerbosity(iterations = Silent())","category":"page"},{"location":"tutorials/developer_tutorial/#Silent-mode","page":"Developer Guide","title":"Silent mode","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"verbose = MySolverVerbosity(     initialization = Silent(),     iterations = Silent(),     convergence = Silent(),     warnings = Silent() )","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"","category":"page"},{"location":"tutorials/developer_tutorial/#Complete-Example","page":"Developer Guide","title":"Complete Example","text":"","category":"section"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"Here's a complete minimal example:","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"using SciMLLogging\nusing ConcreteStructs: @concrete\nimport SciMLLogging: AbstractVerbositySpecifier\n\n@concrete struct ExampleVerbosity <: AbstractVerbositySpecifier\n    progress\nend\n\n# Constructor with default\nExampleVerbosity(; progress = InfoLevel()) = ExampleVerbosity(progress)\n\nfunction solve_example(n::Int, verbose::ExampleVerbosity)\n    result = 0\n    for i in 1:n\n        result += i\n        @SciMLMessage(\"Step $i: sum = $result\", verbose, :progress)\n    end\n    return result\nend","category":"page"},{"location":"tutorials/developer_tutorial/","page":"Developer Guide","title":"Developer Guide","text":"This example shows the minimal structure needed to integrate SciMLLogging into a package.","category":"page"},{"location":"#SciMLLogging.jl","page":"Home","title":"SciMLLogging.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A verbosity control system for the SciML ecosystem that provides fine-grained control over logging and messaging in scientific computing workflows.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fine-grained control: Control individual aspects of logging with specific verbosity settings\nType-safe interface: Leverage Julia's type system for compile-time safety  \nZero-cost abstraction: Disabled verbosity has no runtime overhead\nIntegration with Julia's logging: Built on top of Julia's standard logging infrastructure","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SciMLLogging, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SciMLLogging\")","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use SciMLLogging.jl in your research, please cite the SciML organization:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{SciMLLogging,\n  author = {SciML},\n  title = {SciMLLogging.jl: Verbosity Control for Scientific Machine Learning},\n  url = {https://github.com/SciML/SciMLLogging.jl},\n  version = {v1.0.0},\n}","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See Getting Started with SciMLLogging.jl for a quick introduction to using SciMLLogging.jl.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums for getting help and asking questions:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"manual/conversion_utilities/#Conversion-Utilities","page":"Conversion Utilities","title":"Conversion Utilities","text":"","category":"section"},{"location":"manual/conversion_utilities/","page":"Conversion Utilities","title":"Conversion Utilities","text":"SciMLLogging provides utility functions to convert message levels to common formats used by other packages.","category":"page"},{"location":"manual/conversion_utilities/#Integer-Conversion","page":"Conversion Utilities","title":"Integer Conversion","text":"","category":"section"},{"location":"manual/conversion_utilities/#SciMLLogging.verbosity_to_int","page":"Conversion Utilities","title":"SciMLLogging.verbosity_to_int","text":"    `verbosity_to_int(verb::AbstractMessageLevel)`\n\nTakes a `AbstractMessageLevel` and gives a corresponding integer value.\nVerbosity settings that use integers or enums that hold integers are relatively common.\nThis provides an interface so that these packages can be used with SciMLVerbosity. Each of the basic verbosity levels\nare mapped to an integer.\n\n```julia\n\nusing SciMLLogging\n\n# Standard levels\n\nverbosity_to_int(Silent())        # Returns 0\nverbosity_to_int(DebugLevel())    # Returns 1\nverbosity_to_int(InfoLevel())     # Returns 2\nverbosity_to_int(WarnLevel())     # Returns 3\nverbosity_to_int(ErrorLevel())    # Returns 4\n\n# Custom levels\n\nverbosity_to_int(CustomLevel(10)) # Returns 10\nverbosity_to_int(CustomLevel(-5)) # Returns -5\n```\n\n\n\n\n\n","category":"function"},{"location":"manual/conversion_utilities/#Boolean-Conversion","page":"Conversion Utilities","title":"Boolean Conversion","text":"","category":"section"},{"location":"manual/conversion_utilities/#SciMLLogging.verbosity_to_bool","page":"Conversion Utilities","title":"SciMLLogging.verbosity_to_bool","text":"    `verbosity_to_bool(verb::AbstractMessageLevel)`\n    \nTakes a `AbstractMessageLevel` and gives a corresponding boolean value.\nVerbosity settings that use booleans are relatively common.\nThis provides an interface so that these packages can be used with SciMLVerbosity.\nIf the verbosity is `Silent`, then `false` is returned. Otherwise, `true` is returned.\n\n```julia\nusing SciMLLogging\n\n# Silent returns false\nverbosity_to_bool(Silent())        # Returns false\n\n# All other levels return true\nverbosity_to_bool(InfoLevel())     # Returns true\nverbosity_to_bool(WarnLevel())     # Returns true\nverbosity_to_bool(ErrorLevel())    # Returns true\nverbosity_to_bool(CustomLevel(5))  # Returns true\n```\n\n\n\n\n\n","category":"function"},{"location":"manual/conversion_utilities/#Usage-Examples","page":"Conversion Utilities","title":"Usage Examples","text":"","category":"section"},{"location":"manual/conversion_utilities/#Integrating-with-Integer-Based-Packages","page":"Conversion Utilities","title":"Integrating with Integer-Based Packages","text":"","category":"section"},{"location":"manual/conversion_utilities/","page":"Conversion Utilities","title":"Conversion Utilities","text":"# Package that expects integer verbosity levels\nfunction external_solver(problem; verbosity_level = 0)\n    if verbosity_level >= 1\n        println(\"Starting solver...\")\n    end\n    # ...\nend\n\n# Use with SciMLLogging\nverbose_spec = MyPackageVerbosity(Standard())\nlevel = verbosity_to_int(verbose_spec.progress)\nresult = external_solver(problem, verbosity_level = level)","category":"page"},{"location":"manual/conversion_utilities/#Integrating-with-Boolean-Based-Packages","page":"Conversion Utilities","title":"Integrating with Boolean-Based Packages","text":"","category":"section"},{"location":"manual/conversion_utilities/","page":"Conversion Utilities","title":"Conversion Utilities","text":"# Package that expects boolean verbosity\nfunction simple_algorithm(data; verbose = false)\n    if verbose\n        println(\"Processing data...\")\n    end\n    # ...\nend\n\n# Use with SciMLLogging\nverbose_spec = MyPackageVerbosity(Standard())\nis_verbose = verbosity_to_bool(verbose_spec.progress)\nresult = simple_algorithm(data, verbose = is_verbose)","category":"page"},{"location":"tutorials/user_tutorial/#User-Tutorial:-Configuring-Package-Verbosity","page":"User Guide","title":"User Tutorial: Configuring Package Verbosity","text":"","category":"section"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"This tutorial is for end users who want to control the verbosity of packages that use SciMLLogging.jl. Each package will have it's own implementation of the AbstractVerbositySpecifier type, which defines the available verbosity options. This guide is meant to be a general guide to the specifics of SciMLLogging.jl, as well as give some examples of how the system is typically implemented. For details on the specific verbosity settings of a package, refer to that package's documentation.","category":"page"},{"location":"tutorials/user_tutorial/#Quick-Start","page":"User Guide","title":"Quick Start","text":"","category":"section"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"Packages that use SciMLLogging typically provide a keyword argument such as verbose or verbosity to control output. The easiest way to get started is with verbosity presets.","category":"page"},{"location":"tutorials/user_tutorial/#Using-Verbosity-Presets-(Recommended)","page":"User Guide","title":"Using Verbosity Presets (Recommended)","text":"","category":"section"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"Most of the time, you'll want to use one of the built-in presets rather than configuring individual message categories:","category":"page"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"Available Presets:","category":"page"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"None(): Log nothing at all \nMinimal(): Only essential messages and warnings\nStandard(): Balanced verbosity suitable for typical usage\nDetailed(): Comprehensive verbosity for debugging and analysis\nAll(): Maximum verbosity","category":"page"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"using SciMLLogging\n\n# No output at all - best for production\nresult = solve(problem, verbose = SolverVerbosity(None()))\n\n# Minimal output - only critical messages\nresult = solve(problem, verbose = SolverVerbosity(Minimal()))\n\n# Standard output - balanced for typical usage (recommended)\nresult = solve(problem, verbose = SolverVerbosity(Standard()))\n\n# Detailed output - comprehensive information for debugging\nresult = solve(problem, verbose = SolverVerbosity(Detailed()))\n\n# Maximum output - show everything\nresult = solve(problem, verbose = SolverVerbosity(All()))","category":"page"},{"location":"tutorials/user_tutorial/#Custom-Verbosity-Configuration","page":"User Guide","title":"Custom Verbosity Configuration","text":"","category":"section"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"For more control, you can configure individual message categories:","category":"page"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"# Example: Customizing a solve's verbosity\nverbose_settings = SolverVerbosity(\n    initialization = InfoLevel(),      # Show startup messages\n    iterations = Silent(),             # Don't show each iteration\n    convergence = InfoLevel(),         # Show convergence information\n    error_control = WarnLevel()        # Show warnings related to error control of the solver\n)\n\nresult = solve(problem, verbose = verbose_settings)","category":"page"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"Message Levels:","category":"page"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"Silent(): No output for this category\nDebugLevel(): Lowest priority debug messages\nInfoLevel(): Informational messages\nWarnLevel(): Warning messages\nErrorLevel(): Error messages\nCustomLevel(n): Custom level with integer value n","category":"page"},{"location":"tutorials/user_tutorial/#Complete-Working-Example","page":"User Guide","title":"Complete Working Example","text":"","category":"section"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"Here's a full example showing how SciMLLogging works in practice, using a simulated \"solver\":","category":"page"},{"location":"tutorials/user_tutorial/","page":"User Guide","title":"User Guide","text":"using SciMLLogging\nusing SciMLLogging: None, Standard, All\nusing ConcreteStructs: @concrete\n\n# 1. Define a verbosity specifier (this would typically be done by a package)\n@concrete struct SolverVerbosity <: AbstractVerbositySpecifier\n    initialization\n    iterations\n    convergence\n    linear_solve\n    warnings\nend\n\n# Likewise the constructors would typically be implemented by a package\nfunction SolverVerbosity(;\n    initialization = Info(),\n    iterations = Silent(),\n    convergence = InfoLevel(),\n    linear_solve = Silent(),\n    warnings = WarnLevel()\n    )\n    SolverVerbosity(initialization, iterations, convergence, linear_solve, warnings)\nend\n\n# 2. Implement preset support\nfunction SolverVerbosity(preset::None)\n    SolverVerbosity(Silent(), Silent(), Silent(), Silent(), Silent())\nend\n\nfunction SolverVerbosity(preset::Standard)\n    SolverVerbosity(InfoLevel(), Silent(), InfoLevel(), Silent(), WarnLevel())\nend\n\nfunction SolverVerbosity(preset::All)\n    SolverVerbosity(InfoLevel(), InfoLevel(), InfoLevel(), InfoLevel(), WarnLevel())\nend\n\n# 3. Example solver function using SciMLLogging, the specific messages and where the messages are emitted\n# would be decided by the package\nfunction example_solver(problem; verbose = SolverVerbosity(Standard()), max_iterations = 10)\n    @SciMLMessage(\"Initializing solver for problem of size $(length(problem))\", verbose, :initialization)\n\n    # Simulate solver iterations\n    for i in 1:max_iterations\n        @SciMLMessage(\"Iteration $i: residual = $(0.1^i)\", verbose, :iterations)\n\n        if i % 3 == 0\n            @SciMLMessage(\"Solving linear system\", verbose, :linear_solve)\n        end\n\n        if 0.1^i < 1e-6\n            @SciMLMessage(\"Converged after $i iterations\", verbose, :convergence)\n            return \"Solution found\"\n        end\n\n        if i == 8\n            @SciMLMessage(\"Solver may be slow to converge\", verbose, :warnings)\n        end\n    end\n\n    @SciMLMessage(\"Maximum iterations reached\", verbose, :warnings)\n    return \"Max iterations\"\nend\n\n# 4. Try different verbosity levels\nproblem = [1.0, 2.0, 3.0]\n\nprintln(\"=== With Standard verbosity ===\")\nresult1 = example_solver(problem, verbose = SolverVerbosity(Standard()))\n\nprintln(\"\\n=== With All verbosity ===\")\nresult2 = example_solver(problem, verbose = SolverVerbosity(All()))\n\nprintln(\"\\n=== With None verbosity ===\")\nresult3 = example_solver(problem, verbose = SolverVerbosity(None()))\n\nprintln(\"\\n=== With custom verbosity ===\")\ncustom_verbose = SolverVerbosity(\n    initialization = InfoLevel(),\n    iterations = Silent(),\n    convergence = InfoLevel(),\n    linear_solve = InfoLevel(),\n    warnings = ErrorLevel()  # Treat warnings as errors for this run\n)\nresult4 = example_solver(problem, verbose = custom_verbose)","category":"page"}]
}
